/*============================================================================*
 * Copyright (c) 2012 Andrew T. Canaday
 *
 * This file is part of ymo_assert, which is licensed under the MIT license.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *----------------------------------------------------------------------------*/
#ifndef YMO_ASSERT_H
#define YMO_ASSERT_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/** # ymo_assert.h
 *
 * These are just a handful of assertion macro definitions from an old project
 * of mine.  They don't do much beyond what you can do with `assert()`.  If
 * you're using a unit test library, you definitely don't need them!  They're
 * just handy for small programs / `check_PROGRAMS` targets.
 *
 * Run `make check` to see an example.
 *
 * This project is licensed under the MIT license. See COPYING for more info.
 *
 * > :information_source: Documentation is generated using
 * > [pomd4c](https://github.com/andrew-canaday/pomd4c).
 *
 * ## Settings
 *
 */

#ifndef YMO_ASSERT_QUIET
/** If set to 1, no output will be generated by any ymo_* assertions. */
# define YMO_ASSERT_QUIET 0
#endif /* YMO_ASSERT_QUIET */


#ifndef YMO_ASSERT_VERBOSE
/** If set to 1, output will also be generated for passing assertions. */
# define YMO_ASSERT_VERBOSE 0
#endif /* YMO_ASSERT_VERBOSE */


#ifndef YMO_ASSERT_FILE
/** Default file stream for verbose output, if undefined. */
# define YMO_ASSERT_FILE stderr
#endif /* YMO_ASSERT_FILE */



/*--------------------------------------------------
 *              Convenience Macros:
 *--------------------------------------------------*/
#ifndef ymo_assert_fail_action
# if defined(YMO_TEST_ABORT_RETURN) && (YMO_TEST_ABORT_RETURN==1)
#  define ymo_assert_fail_action() return 0
# else
/** Default action to take for a failed assertion, if undefined. */
#  define ymo_assert_fail_action() exit(-1)
# endif /*YMO_TEST_ABORT_RETURN */
#endif /* ymo_assert_fail_action */


#if YMO_ASSERT_QUIET == 0
/* Function used to report test failure and invoke failure action. */
# define ymo_assert_fail(test_desc) \
    fprintf(YMO_ASSERT_FILE, "\n\033[00;31mFAIL: %s (%s:%s:%i)\033[00;m\n", \
        test_desc, __FILE__, __func__, __LINE__); \
    ymo_assert_fail_action();
#else
# define ymo_assert_fail(test_desc) ((void)0)
#endif /* YMO_ASSERT_QUIET */


#if (YMO_ASSERT_VERBOSE == 1) && (YMO_ASSERT_QUIET != 1)
/* Function used to report test success, if verbose is defined. */
#define ymo_assert_pass(test_desc) \
    fprintf(YMO_ASSERT_FILE, "\033[00;32mPASS: %s (%s:%s:%i)\033[00;m\n", \
        test_desc, __FILE__, __func__, __LINE__);
#else
#define ymo_assert_pass(test_desc) ((void)0)
#endif /* YMO_ASSERT_VERBOSE */


/* Convenience macro used to execute tests and report failure */
#ifndef NDEBUG
# define ymo_assert_condition(test_cond, test_desc) \
    do { \
        if( test_cond ) { \
            ymo_assert_pass(test_desc); \
        } else { \
            ymo_assert_fail(test_desc); \
        } \
    } while(0)
#else
#define ymo_assert_condition(test_cond, test_desc) ((void)0)
#endif /* NDEBUG */


/*-------------------------------------
           Assertion Macros:
 *-------------------------------------*/

/** ## Assertions
 *
 * This is the basic assertion. It works just like `assert()` save for the
 * fact that failure behavior can be customized by defining
 * `ymo_assert_fail_action` prior to including ymo_assert.h.
 */
#define ymo_assert( test_cond ) ymo_assert_condition(test_cond, #test_cond)


/** ### String Assertions */

/** #### ymo_assert_str_eq
 *
 *  - pass if two non-null strings are lexicographically equal
 *  - pass if both strings are the NULL pointer
 */
#define ymo_assert_str_eq( x, y ) ymo_assert_condition( \
        (x && y && !strcmp((const char*)x,(const char*)y)) \
            || ((x == NULL) && (y == NULL)), #x " == " #y )


/** #### ymo_assert_str_ne
 *
 * Pass if either:
 *  - two non-null strings are not lexicographically equal
 *  - one string is NULL and the other isn't
 */
#define ymo_assert_str_ne( x, y ) ymo_assert_condition( \
        (x && y && strcmp((const char*)x,(const char*)y)) \
        || ((x == NULL || y == NULL) && (x!=y)), #x " != " #y )


/** ### ymo_assert_str_contains
 *
 * Substring matching: pass if x is a substring of y.
 */
#define ymo_assert_str_contains( x, y ) ymo_assert_condition( \
        x && y && strstr(x, y) != NULL, #x " contains " #y)


/** ### ymo_assert_str_startswith
 *
 * Prefix matching: pass if x starts with y.
 */
#define ymo_assert_str_startswith( x, y ) ymo_assert_condition( \
        x && y && ((const char*)strstr(x, y)) == (const char*)x, \
        #x " starts with " #y)


#endif /* YMO_ASSERT_H */
/* EOF */

